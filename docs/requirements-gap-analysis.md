# Оценка текущего состояния сервиса

Ниже перечислены требования из запроса и текущее состояние кода на их счёт. Это позволяет увидеть, какие блоки уже покрыты реализацией, а какие потребуют новой разработки.

## 1. Инициализация сервиса и загрузка данных по REST API

* Функция `startup` в FastAPI-приложении только выполняет discovery символов и запускает раннеры коннекторов. Она не обращается к REST API бирж за историческими данными, перечнем контрактов или комиссиями. 【F:backend/src/arbitrage_scanner/app.py†L124-L144】
* Соответственно, на старте нет заполнения базы (или даже in-memory стора) историческими бид/аск снапшотами за 10 дней, ставками фандинга или кастомными комиссиями тейкера — коннекторы начинают работать только после подключения по WebSocket.

## 2. Хранение данных в базе

* Единственное хранилище данных сейчас — `TickerStore`, который держит тикеры, фандинг и ордербуки в оперативной памяти и предоставляет сериализацию в виде словарей. Взаимодействия с БД, драйверов и моделей хранения нет вовсе. 【F:backend/src/arbitrage_scanner/store.py†L46-L133】

## 3. Нормализация и сопоставление контрактов

* Отдельные коннекторы выполняют локальную нормализацию собственных символов, но нет общего слоя, который бы приводил названия контрактов к каноническому виду и сохранял соответствия между биржами. В `startup` символы просто берутся из пересечения discovery-функций и дальше используются как есть. 【F:backend/src/arbitrage_scanner/app.py†L124-L143】

## 4. Подписка по WebSocket на топы стаканов

* Коннекторы действительно подписываются на WebSocket-потоки и обновляют стор лучшими бид/аск ценами, а также ордербуками. Например, Binance-коннектор сохраняет лучшие котировки и стакан при каждом апдейте. 【F:backend/src/arbitrage_scanner/connectors/binance_futures.py†L160-L205】
* Однако эти данные не дополняются историей из REST API, поэтому расчёт «входа»/«выхода» доступен только после накопления in-memory данных во время работы сервиса.

## 5. Периодический опрос фандинга по REST API

* В текущем коде фандинг приходит исключительно из WebSocket-сообщений коннекторов. Периодического фонового запроса по REST API с агрегацией ставки и периода расчёта нет. 【F:backend/src/arbitrage_scanner/connectors/binance_futures.py†L197-L205】

## 6. Исторические графики на странице пары

* Исторические графики строятся на основании in-memory класса `SpreadHistory`, который заполняется только текущими расчётами спреда (и опционально бэкапится спред-историей по API). Реальных исторических бид/аск снапшотов бирж в базе нет. 【F:backend/src/arbitrage_scanner/engine/spread_history.py†L37-L142】

## 7. Полные ордербуки по выбранной паре

* Хранилище `TickerStore` умеет хранить ордербуки, и коннекторы их обновляют, но нет механизма on-demand подписки только при открытии карточки пары. Все ордербуки подтягиваются постоянно, что повышает нагрузку. 【F:backend/src/arbitrage_scanner/store.py†L61-L133】【F:backend/src/arbitrage_scanner/connectors/binance_futures.py†L160-L205】

## 8. Расчёт спредов с учётом объёма из ордербуков

* Расчёт «входа» и «выхода» базируется на лучших бид/аск ценах и не учитывает объём сделки. Логика обхода ордербуков и расчёта средневзвешенной цены отсутствует. 【F:backend/src/arbitrage_scanner/engine/spread_calc.py†L16-L111】

## Вывод

Чтобы выполнить поставленную задачу, потребуется:

1. Добавить слой доступа к БД (модель данных для тикеров, истории, фандинга и стаканов) и фоновые воркеры для сохранения данных.
2. Расширить инициализацию сервиса запросами к REST API бирж (исторические котировки, комиссии тейкера, ставки фандинга) с записью результатов в базу.
3. Ввести единый словарь нормализации контрактов и сопоставление между биржами.
4. Переделать подписки на ордербуки, чтобы они включались только для открытых карточек и учитывали объём при расчёте спреда.
5. Обновить API/UI, чтобы работать с данными из БД и поддерживать комбинированные графики (история + realtime).

Документ фиксирует технический долг перед внедрением новой логики.
